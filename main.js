// Generated by CoffeeScript 1.7.1
(function() {
  var DEBUG_MODE, NodeArgs, answer_idx, colors, default_max_words, dictionary_data, dictionary_data_raw, dictionary_file, fs, hint_idx, i, line, max_words, process_args, prompt, prompts, score_results, shuffle_words, theprompt, word, words, _, _debug, _i, _len, _str;

  prompt = require("prompt");

  colors = require("colors");

  _ = require("underscore");

  _str = require("underscore.string");

  fs = require("fs");

  NodeArgs = (function() {
    function NodeArgs() {
      var arg, sp, _i, _len, _ref;
      this.args = {};
      this.flags = [];
      this.keys = [];
      _ref = process.argv;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        arg = _ref[_i];
        if (arg.indexOf("=") > -1) {
          sp = arg.split("=");
          this.args[sp[0]] = sp[1];
          this.keys.push(sp[0]);
        } else {
          this.args[arg] = 1;
          this.flags.push(arg);
        }
      }
    }

    NodeArgs.prototype.on = function(flag_or_key, fn) {
      var found_flag, found_key;
      if (fn == null) {
        fn = null;
      }
      found_flag = this.flags.indexOf(flag_or_key) > -1;
      found_key = this.keys.indexOf(flag_or_key) > -1;
      if (found_flag) {
        return typeof fn === "function" ? fn() : void 0;
      } else if (found_key) {
        return typeof fn === "function" ? fn(this.args[flag_or_key]) : void 0;
      }
    };

    NodeArgs.prototype.has_flag = function(flag, strict) {
      var f, found_flag, has_flag, _i, _len;
      if (strict == null) {
        strict = false;
      }
      found_flag = flag;
      if (typeof flag === "object") {
        for (_i = 0, _len = flag.length; _i < _len; _i++) {
          f = flag[_i];
          if (!has_flag) {
            has_flag = this.args.hasOwnProperty(f);
            if (has_flag) {
              found_flag = f;
            }
          }
        }
      } else {
        has_flag = this.args.hasOwnProperty(flag);
      }
      if (!has_flag || (has_flag && !strict)) {
        return has_flag;
      }
      return this.args[found_flag] === 1;
    };

    NodeArgs.prototype.has_val = function(key) {
      return this.has_flag(key);
    };

    NodeArgs.prototype.val = function(key) {
      if (this.args.hasOwnProperty(key)) {
        return this.args[key];
      } else {
        return false;
      }
    };

    NodeArgs.prototype.arg_equals = function(key, val) {
      return this.val(key) === val;
    };

    NodeArgs.prototype.data = function() {
      return this.args;
    };

    return NodeArgs;

  })();

  process_args = new NodeArgs();

  DEBUG_MODE = process_args.has_flag("--debug");

  _debug = function(msg) {
    if (!DEBUG_MODE) {
      return;
    }
    return console.log(colors.yellow(msg));
  };

  dictionary_file = process_args.has_val("--dictionary") ? "dictionaries/" + (process_args.val('--dictionary')) + ".csv" : "dictionary.csv";

  _debug("selected dictionary: " + dictionary_file);

  dictionary_data_raw = fs.readFileSync("" + __dirname + "/" + dictionary_file, "UTF-8");

  dictionary_data = (function() {
    var _i, _len, _ref, _results;
    _ref = dictionary_data_raw.split("\n");
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      line = _ref[_i];
      if (!_.isEmpty(line)) {
        _results.push((function() {
          var _j, _len1, _ref1, _results1;
          _ref1 = line.split(",");
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            word = _ref1[_j];
            _results1.push(_str.trim(word));
          }
          return _results1;
        })());
      } else {
        _results.push(null);
      }
    }
    return _results;
  })();

  dictionary_data = _.reject(dictionary_data, (function(_this) {
    return function(w) {
      return w === null || w === void 0;
    };
  })(this));

  _debug("loaded " + dictionary_data.length + " total words");

  prompt.message = ">>>";

  prompt.delimiter = " ";

  prompt.start();

  hint_idx = 0;

  answer_idx = 1;

  default_max_words = 999;

  shuffle_words = process_args.has_flag("--shuffle");

  max_words = process_args.has_flag("--num_words") ? parseInt(process_args.val("--num_words")) : default_max_words;

  words = shuffle_words ? _.shuffle(dictionary_data) : dictionary_data;

  prompts = [];

  if (shuffle_words) {
    _debug("shuffle enabled");
  }

  if (max_words < words.length) {
    words = _.first(words, max_words);
    console.log("" + max_words + " words loaded! This is just a slice of the dictionary.");
  } else {
    console.log("" + words.length + " words loaded! This is the entire dictionary.");
  }

  for (i = _i = 0, _len = words.length; _i < _len; i = ++_i) {
    word = words[i];
    theprompt = {
      name: "word_" + i,
      description: word[hint_idx]
    };
    prompts.push(theprompt);
  }

  score_results = function(results) {
    var correct, guess, idx, key, score, source, wrong, wrong_indexes, wrong_words, _j, _len1;
    correct = 0;
    wrong = 0;
    score = 0;
    wrong_indexes = [];
    for (key in results) {
      guess = results[key];
      idx = parseInt(key.substr(key.indexOf("_") + 1));
      source = words[idx];
      if (guess === source[answer_idx]) {
        correct++;
      } else {
        wrong++;
        wrong_indexes.push(idx);
      }
    }
    score = correct === 0 ? 0 : correct / (wrong + correct);
    wrong_words = [];
    for (_j = 0, _len1 = wrong_indexes.length; _j < _len1; _j++) {
      i = wrong_indexes[_j];
      wrong_words.push(words[i]);
    }
    _debug("score_results: score: " + score + ", correct:" + correct + ", wrong:" + wrong);
    return [score, correct, wrong, wrong_words];
  };

  prompt.get(prompts, function(err, result) {
    var correct, score, wrong, wrong_words, _j, _len1, _ref, _results;
    _ref = score_results(result), score = _ref[0], correct = _ref[1], wrong = _ref[2], wrong_words = _ref[3];
    console.log(colors.green("You finished with a score of " + (score * 100) + "%"));
    if (wrong) {
      console.log(colors.red("Looks like you need some more practice with the following words:"));
      _results = [];
      for (i = _j = 0, _len1 = wrong_words.length; _j < _len1; i = ++_j) {
        word = wrong_words[i];
        _results.push(console.log(colors.red("" + (i + 1) + ". " + word[hint_idx] + " - " + word[answer_idx])));
      }
      return _results;
    }
  });

}).call(this);
