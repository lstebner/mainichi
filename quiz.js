// Generated by CoffeeScript 1.7.1
(function() {
  var DEBUG_MODE, NodeArgs, answer, answer_idx, colors, default_max_words, default_quiz_mode, dictionary_data, dictionary_data_raw, dictionary_file, fs, hint_idx, how_many, i, invert_at_random, invert_hints, line, max_num, max_words, num1, num2, operator, operators, problem, process_args, process_end_time, process_setup_time, process_start_time, prompt, prompt_end_time, prompt_start_time, prompts, quiz_mode, quiz_modes, randomly_invert_hints, score_results, shuffle_words, theprompt, timed, word, words, _, _debug, _i, _len, _str;

  prompt = require("prompt");

  colors = require("colors");

  _ = require("underscore");

  _str = require("underscore.string");

  fs = require("fs");

  NodeArgs = (function() {
    function NodeArgs() {
      var arg, sp, _i, _len, _ref;
      this.args = {};
      this.flags = [];
      this.keys = [];
      _ref = process.argv;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        arg = _ref[_i];
        if (arg.indexOf("=") > -1) {
          sp = arg.split("=");
          this.args[sp[0]] = sp[1];
          this.keys.push(sp[0]);
        } else {
          this.args[arg] = 1;
          this.flags.push(arg);
        }
      }
    }

    NodeArgs.prototype.on = function(flag_or_key, fn) {
      var found_flag, found_key;
      if (fn == null) {
        fn = null;
      }
      found_flag = this.flags.indexOf(flag_or_key) > -1;
      found_key = this.keys.indexOf(flag_or_key) > -1;
      if (found_flag) {
        return typeof fn === "function" ? fn() : void 0;
      } else if (found_key) {
        return typeof fn === "function" ? fn(this.args[flag_or_key]) : void 0;
      }
    };

    NodeArgs.prototype.has_flag = function(flag, strict) {
      var f, found_flag, has_flag, _i, _len;
      if (strict == null) {
        strict = false;
      }
      found_flag = flag;
      if (typeof flag === "object") {
        for (_i = 0, _len = flag.length; _i < _len; _i++) {
          f = flag[_i];
          if (!has_flag) {
            has_flag = this.args.hasOwnProperty(f);
            if (has_flag) {
              found_flag = f;
            }
          }
        }
      } else {
        has_flag = this.args.hasOwnProperty(flag);
      }
      if (!has_flag || (has_flag && !strict)) {
        return has_flag;
      }
      return this.args[found_flag] === 1;
    };

    NodeArgs.prototype.has_val = function(key) {
      return this.has_flag(key);
    };

    NodeArgs.prototype.val = function(key) {
      if (this.args.hasOwnProperty(key)) {
        return this.args[key];
      } else {
        return false;
      }
    };

    NodeArgs.prototype.arg_equals = function(key, val) {
      return this.val(key) === val;
    };

    NodeArgs.prototype.data = function() {
      return this.args;
    };

    return NodeArgs;

  })();

  process_args = new NodeArgs();

  process_start_time = (new Date).getTime();

  process_end_time = 0;

  DEBUG_MODE = process_args.has_flag("--debug");

  _debug = function(msg) {
    if (!DEBUG_MODE) {
      return;
    }
    return console.log(colors.yellow(msg));
  };

  prompt.message = ">>>";

  prompt.delimiter = " ";

  prompt.start();

  quiz_modes = ["qa", "echo", "math"];

  default_quiz_mode = "qa";

  quiz_mode = process_args.has_flag("--mode") ? process_args.val("--mode") : default_quiz_mode;

  if (_.indexOf(quiz_modes, quiz_mode) < 0) {
    console.log(colors.red("invalid quiz mode selected '" + quiz_mode + "'; using default"));
    quiz_mode = default_quiz_mode;
  }

  if (quiz_mode === "math") {
    how_many = 500;
    max_num = 19;
    operators = ["+", "-"];
    dictionary_data = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= how_many ? _i <= how_many : _i >= how_many; i = 0 <= how_many ? ++_i : --_i) {
        operator = operators[Math.floor(Math.random() * operators.length)];
        num1 = Math.ceil(Math.random() * max_num);
        num2 = Math.ceil(Math.random() * max_num);
        problem = "" + num1 + " " + operator + " " + num2;
        answer = eval(problem);
        _results.push([problem, answer]);
      }
      return _results;
    })();
  } else {
    dictionary_file = process_args.has_val("--dictionary") ? "dictionaries/" + (process_args.val('--dictionary')) + ".csv" : "dictionary.csv";
    _debug("selected dictionary: " + dictionary_file);
    dictionary_data_raw = fs.readFileSync("" + __dirname + "/" + dictionary_file, "UTF-8");
    dictionary_data = (function() {
      var _i, _len, _ref, _results;
      _ref = dictionary_data_raw.split("\n");
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        if (!_.isEmpty(line)) {
          _results.push((function() {
            var _j, _len1, _ref1, _results1;
            _ref1 = line.split(",");
            _results1 = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              word = _ref1[_j];
              _results1.push(_str.trim(word));
            }
            return _results1;
          })());
        } else {
          _results.push(null);
        }
      }
      return _results;
    })();
    dictionary_data = _.reject(dictionary_data, (function(_this) {
      return function(w) {
        return w === null || w === void 0;
      };
    })(this));
    _debug("loaded " + dictionary_data.length + " total words");
  }

  default_max_words = 999;

  shuffle_words = process_args.has_flag("--shuffle");

  timed = process_args.has_flag("--timed");

  invert_hints = false;

  randomly_invert_hints = false;

  max_words = process_args.has_flag("--num_words") ? parseInt(process_args.val("--num_words")) : default_max_words;

  words = shuffle_words ? _.shuffle(dictionary_data) : dictionary_data;

  prompts = [];

  if (process_args.has_flag("--invert")) {
    if (process_args.val("--invert") === "random") {
      randomly_invert_hints = true;
    } else {
      invert_hints = true;
    }
  }

  hint_idx = invert_hints ? 1 : 0;

  answer_idx = invert_hints ? 0 : 1;

  _debug("quiz mode is " + quiz_mode);

  _debug("shuffle is " + (shuffle_words ? 'enabled' : ''));

  _debug("invert_hints is " + (invert_hints ? 'enabled' : 'disabled'));

  _debug("randomly_invert_hints is " + (randomly_invert_hints ? 'enabled' : 'disabled'));

  _debug("timed is " + (timed ? 'enabled' : ''));

  if (max_words < words.length) {
    words = _.first(words, max_words);
    console.log("" + max_words + " words loaded! This is just a slice of the dictionary.");
  } else {
    console.log("" + words.length + " words loaded! This is the entire dictionary.");
  }

  for (i = _i = 0, _len = words.length; _i < _len; i = ++_i) {
    word = words[i];
    invert_at_random = randomly_invert_hints ? (Math.floor(Math.random() * 100)) % 2 === 0 : false;
    theprompt = {
      name: "" + (invert_at_random ? '-' : '') + "word_" + i,
      description: invert_at_random ? word[answer_idx] : word[hint_idx]
    };
    prompts.push(theprompt);
  }

  score_results = function(results) {
    var correct, guess, idx, inverted, key, score, source, wrong, wrong_indexes, wrong_words, _j, _len1;
    correct = 0;
    wrong = 0;
    score = 0;
    wrong_indexes = [];
    for (key in results) {
      guess = results[key];
      idx = parseInt(key.substr(key.indexOf("_") + 1));
      source = words[idx];
      inverted = key.charAt(0) === "-";
      switch (quiz_mode) {
        case "qa":
          if ((inverted && guess === source[hint_idx]) || (!inverted && guess === source[answer_idx])) {
            correct++;
          } else {
            wrong++;
            wrong_indexes.push(idx);
          }
          break;
        case "echo":
          if (guess === source[hint_idx]) {
            correct++;
          } else {
            wrong++;
            wrong_indexes.push(idx);
          }
          break;
        case "math":
          if (parseInt(guess) === source[answer_idx]) {
            correct++;
          } else {
            wrong++;
            wrong_indexes.push(idx);
          }
      }
    }
    score = correct === 0 ? 0 : correct / (wrong + correct);
    wrong_words = [];
    for (_j = 0, _len1 = wrong_indexes.length; _j < _len1; _j++) {
      i = wrong_indexes[_j];
      wrong_words.push(words[i]);
    }
    _debug("score_results: score: " + score + ", correct:" + correct + ", wrong:" + wrong);
    return [score, correct, wrong, wrong_words];
  };

  process_setup_time = (new Date).getTime() - process_start_time;

  if (process_setup_time < 1000) {
    process_setup_time = "<1";
  } else {
    process_setup_time = process_setup_time / 1000;
  }

  _debug("setup completed in " + process_setup_time + " seconds");

  prompt_start_time = (new Date).getTime();

  prompt_end_time = 0;

  prompt.get(prompts, function(err, result) {
    var correct, finished_msg, process_completion_time, prompt_completion_time, score, wrong, wrong_words, _j, _len1, _ref;
    _ref = score_results(result), score = _ref[0], correct = _ref[1], wrong = _ref[2], wrong_words = _ref[3];
    prompt_end_time = (new Date).getTime();
    prompt_completion_time = (prompt_end_time - prompt_start_time) / 1000;
    finished_msg = "You finished with a score of " + (score * 100) + "%";
    if (timed) {
      finished_msg += " in a time of " + prompt_completion_time + " seconds";
    }
    console.log(colors.green(finished_msg));
    if (wrong) {
      console.log(colors.red("Looks like you need some more practice with the following:"));
      for (i = _j = 0, _len1 = wrong_words.length; _j < _len1; i = ++_j) {
        word = wrong_words[i];
        switch (quiz_mode) {
          case "qa":
            console.log(colors.red("" + (i + 1) + ". " + word[hint_idx] + " - " + word[answer_idx]));
            break;
          case "echo":
            console.log(colors.red("" + (i + 1) + ". " + word[hint_idx]));
            break;
          case "math":
            console.log(colors.red("" + (i + 1) + ". " + word[hint_idx] + " = " + word[answer_idx]));
        }
      }
    }
    process_end_time = (new Date).getTime();
    process_completion_time = (process_end_time - process_start_time) / 1000;
    return _debug("process completed in " + process_completion_time + " seconds");
  });

}).call(this);
